<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.40">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Omar Armbruster">
<meta name="dcterms.date" content="2025-03-12">
<meta name="description" content="Analyzing Implicit Bias in Machine Learning Models">

<title>Auditing Bias – Omar Armbruster</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script><script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-549806ee2085284f45b00abea8c6df48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-afd1c537f28ba892ec3c7a1a10902170.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<style>

      .quarto-title-block .quarto-title-banner h1,
      .quarto-title-block .quarto-title-banner h2,
      .quarto-title-block .quarto-title-banner h3,
      .quarto-title-block .quarto-title-banner h4,
      .quarto-title-block .quarto-title-banner h5,
      .quarto-title-block .quarto-title-banner h6
      {
        color: white;
      }

      .quarto-title-block .quarto-title-banner {
        color: white;
background-image: url(../../img/landscape.png);
background-size: cover;
      }
</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" integrity="sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==" crossorigin="anonymous"></script>

<script type="application/javascript">define('jquery', [],function() {return window.jQuery;})</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Omar Armbruster</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/omar-armbruster"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/omar-armbruster-38951621b/"> <i class="bi bi-linkedin" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Auditing Bias</h1>
                  <div>
        <div class="description">
          Analyzing Implicit Bias in Machine Learning Models
        </div>
      </div>
                </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Omar Armbruster </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">March 12, 2025</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<section id="introduction" class="level1">
<h1>Introduction</h1>
<p>Machine learning models show potential to revolutionize automated decision-making processes and have already made their way into many of our daily lives through technologies like personalized recommendations, face identification, and self-driving cars. However, these models can also pose extreme dangers, as the models are only as good as the data they are trained on and can very easily reinforce existing injustices in our society. Even when certain traits like race are omitted from the training process, models can predict these traits from other features and still reinforce societal norms that we are trying to avoid. We demonstrate this by training a Decision Tree Classifier model on a dataset of responses to the 2018 Public Use Microdata Sample survey in New York and use it to predict whether an individual is likely to employed. We omit race from our training features and then audit our model to determine if it is truly independent from race. We examine three methods of fairness: calibration, error rate balance, and statistical parity, as well as examine feasible false negative and false positive rates.</p>
<p>We begin by importing the folktables package, which we use to import our data. We specify that we are examining responses from 2018 in the state of New York when fetching our data.</p>
<div id="cell-3" class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> folktables <span class="im">import</span> ACSDataSource, ACSEmployment, BasicProblem, adult_filter</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>STATE <span class="op">=</span> <span class="st">"NY"</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>data_source <span class="op">=</span> ACSDataSource(survey_year<span class="op">=</span><span class="st">'2018'</span>, </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>                            horizon<span class="op">=</span><span class="st">'1-Year'</span>, </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>                            survey<span class="op">=</span><span class="st">'person'</span>)</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>acs_data <span class="op">=</span> data_source.get_data(states<span class="op">=</span>[STATE], download<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>acs_data.head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Downloading data for 2018 1-Year person survey for NY...</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="2">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">RT</th>
<th data-quarto-table-cell-role="th">SERIALNO</th>
<th data-quarto-table-cell-role="th">DIVISION</th>
<th data-quarto-table-cell-role="th">SPORDER</th>
<th data-quarto-table-cell-role="th">PUMA</th>
<th data-quarto-table-cell-role="th">REGION</th>
<th data-quarto-table-cell-role="th">ST</th>
<th data-quarto-table-cell-role="th">ADJINC</th>
<th data-quarto-table-cell-role="th">PWGTP</th>
<th data-quarto-table-cell-role="th">AGEP</th>
<th data-quarto-table-cell-role="th">...</th>
<th data-quarto-table-cell-role="th">PWGTP71</th>
<th data-quarto-table-cell-role="th">PWGTP72</th>
<th data-quarto-table-cell-role="th">PWGTP73</th>
<th data-quarto-table-cell-role="th">PWGTP74</th>
<th data-quarto-table-cell-role="th">PWGTP75</th>
<th data-quarto-table-cell-role="th">PWGTP76</th>
<th data-quarto-table-cell-role="th">PWGTP77</th>
<th data-quarto-table-cell-role="th">PWGTP78</th>
<th data-quarto-table-cell-role="th">PWGTP79</th>
<th data-quarto-table-cell-role="th">PWGTP80</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>P</td>
<td>2018GQ0000012</td>
<td>2</td>
<td>1</td>
<td>3802</td>
<td>1</td>
<td>36</td>
<td>1013097</td>
<td>145</td>
<td>26</td>
<td>...</td>
<td>146</td>
<td>146</td>
<td>21</td>
<td>24</td>
<td>266</td>
<td>263</td>
<td>21</td>
<td>146</td>
<td>265</td>
<td>144</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>P</td>
<td>2018GQ0000040</td>
<td>2</td>
<td>1</td>
<td>2702</td>
<td>1</td>
<td>36</td>
<td>1013097</td>
<td>43</td>
<td>21</td>
<td>...</td>
<td>6</td>
<td>42</td>
<td>43</td>
<td>7</td>
<td>40</td>
<td>6</td>
<td>43</td>
<td>40</td>
<td>42</td>
<td>6</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>P</td>
<td>2018GQ0000060</td>
<td>2</td>
<td>1</td>
<td>2001</td>
<td>1</td>
<td>36</td>
<td>1013097</td>
<td>88</td>
<td>18</td>
<td>...</td>
<td>88</td>
<td>163</td>
<td>161</td>
<td>162</td>
<td>87</td>
<td>12</td>
<td>162</td>
<td>88</td>
<td>87</td>
<td>88</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>P</td>
<td>2018GQ0000081</td>
<td>2</td>
<td>1</td>
<td>2401</td>
<td>1</td>
<td>36</td>
<td>1013097</td>
<td>109</td>
<td>85</td>
<td>...</td>
<td>17</td>
<td>15</td>
<td>111</td>
<td>107</td>
<td>17</td>
<td>196</td>
<td>109</td>
<td>200</td>
<td>198</td>
<td>111</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>P</td>
<td>2018GQ0000103</td>
<td>2</td>
<td>1</td>
<td>1400</td>
<td>1</td>
<td>36</td>
<td>1013097</td>
<td>83</td>
<td>19</td>
<td>...</td>
<td>81</td>
<td>12</td>
<td>80</td>
<td>154</td>
<td>12</td>
<td>80</td>
<td>12</td>
<td>83</td>
<td>152</td>
<td>154</td>
</tr>
</tbody>
</table>

<p>5 rows × 286 columns</p>
</div>
</div>
</div>
<p>For the sake of simplicity, we can select specific features to train our model on. We select the following:</p>
<ul>
<li>AGEP - Age</li>
<li>SCHL - Educational attainment</li>
<li>MAR - Marital status</li>
<li>RELP - Relationship to reference person</li>
<li>DIS - Disability</li>
<li>ESP - Employment status of parents</li>
<li>CIT - Citizenship stats</li>
<li>MIG - Mobility status</li>
<li>MIL - Military service</li>
<li>ANC - Ancestry</li>
<li>NATIVITY - Nativity</li>
<li>DEAR - Hearing difficulty</li>
<li>DEYE - Vision difficulty</li>
<li>DREM - Cognitive difficulty</li>
<li>SEX - Sex</li>
<li>RAC1P - Race</li>
<li>ESR - Employment status</li>
</ul>
<div id="cell-5" class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>possible_features<span class="op">=</span>[<span class="st">'AGEP'</span>, <span class="st">'SCHL'</span>, <span class="st">'MAR'</span>, <span class="st">'RELP'</span>, <span class="st">'DIS'</span>, <span class="st">'ESP'</span>, <span class="st">'CIT'</span>, <span class="st">'MIG'</span>, <span class="st">'MIL'</span>, <span class="st">'ANC'</span>, <span class="st">'NATIVITY'</span>, <span class="st">'DEAR'</span>, <span class="st">'DEYE'</span>, <span class="st">'DREM'</span>, <span class="st">'SEX'</span>, <span class="st">'RAC1P'</span>, <span class="st">'ESR'</span>]</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>acs_data[possible_features].head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="3">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">AGEP</th>
<th data-quarto-table-cell-role="th">SCHL</th>
<th data-quarto-table-cell-role="th">MAR</th>
<th data-quarto-table-cell-role="th">RELP</th>
<th data-quarto-table-cell-role="th">DIS</th>
<th data-quarto-table-cell-role="th">ESP</th>
<th data-quarto-table-cell-role="th">CIT</th>
<th data-quarto-table-cell-role="th">MIG</th>
<th data-quarto-table-cell-role="th">MIL</th>
<th data-quarto-table-cell-role="th">ANC</th>
<th data-quarto-table-cell-role="th">NATIVITY</th>
<th data-quarto-table-cell-role="th">DEAR</th>
<th data-quarto-table-cell-role="th">DEYE</th>
<th data-quarto-table-cell-role="th">DREM</th>
<th data-quarto-table-cell-role="th">SEX</th>
<th data-quarto-table-cell-role="th">RAC1P</th>
<th data-quarto-table-cell-role="th">ESR</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>26</td>
<td>21.0</td>
<td>5</td>
<td>17</td>
<td>2</td>
<td>NaN</td>
<td>5</td>
<td>1.0</td>
<td>4.0</td>
<td>1</td>
<td>2</td>
<td>2</td>
<td>2</td>
<td>2.0</td>
<td>2</td>
<td>1</td>
<td>6.0</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>21</td>
<td>20.0</td>
<td>5</td>
<td>17</td>
<td>2</td>
<td>NaN</td>
<td>1</td>
<td>3.0</td>
<td>4.0</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>2</td>
<td>2.0</td>
<td>1</td>
<td>1</td>
<td>1.0</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>18</td>
<td>16.0</td>
<td>5</td>
<td>17</td>
<td>2</td>
<td>NaN</td>
<td>2</td>
<td>3.0</td>
<td>4.0</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>2</td>
<td>2.0</td>
<td>2</td>
<td>8</td>
<td>6.0</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>85</td>
<td>16.0</td>
<td>2</td>
<td>16</td>
<td>1</td>
<td>NaN</td>
<td>1</td>
<td>1.0</td>
<td>4.0</td>
<td>4</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>1.0</td>
<td>2</td>
<td>1</td>
<td>6.0</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>19</td>
<td>19.0</td>
<td>5</td>
<td>17</td>
<td>2</td>
<td>NaN</td>
<td>1</td>
<td>1.0</td>
<td>4.0</td>
<td>2</td>
<td>1</td>
<td>2</td>
<td>2</td>
<td>2.0</td>
<td>2</td>
<td>1</td>
<td>1.0</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>We use the selected features to define our training dataset but exclude employment status (the target variable) and race, which we claim the model will be able to implicitly determine. We define a problem, which specifies our target and hidden features (employment and race).</p>
<p>Looking briefly at our data, it appears we have <span class="math inline">\(196,967\)</span> observations (people) measured with <span class="math inline">\(15\)</span> features. We confirm that our created feature, label, and group objects all have the same length, as each entry should correspond to a single person.</p>
<div id="cell-7" class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>features_to_use <span class="op">=</span> [f <span class="cf">for</span> f <span class="kw">in</span> possible_features <span class="cf">if</span> f <span class="kw">not</span> <span class="kw">in</span> [<span class="st">"ESR"</span>, <span class="st">"RAC1P"</span>]]</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>EmploymentProblem <span class="op">=</span> BasicProblem(</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    features<span class="op">=</span>features_to_use,</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    target<span class="op">=</span><span class="st">'ESR'</span>,</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    target_transform<span class="op">=</span><span class="kw">lambda</span> x: x <span class="op">==</span> <span class="dv">1</span>,</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    group<span class="op">=</span><span class="st">'RAC1P'</span>,</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    preprocess<span class="op">=</span><span class="kw">lambda</span> x: x,</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    postprocess<span class="op">=</span><span class="kw">lambda</span> x: np.nan_to_num(x, <span class="op">-</span><span class="dv">1</span>),</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>features, label, group <span class="op">=</span> EmploymentProblem.df_to_numpy(acs_data)</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> obj <span class="kw">in</span> [features, label, group]:</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>  <span class="bu">print</span>(obj.shape)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>(196967, 15)
(196967,)
(196967,)</code></pre>
</div>
</div>
<p>As is good machine learning practice, we define a testing and training dataset so we can later evaluate how our model performs on unseen data.</p>
<div id="cell-9" class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.model_selection <span class="im">import</span> train_test_split</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>X_train, X_test, y_train, y_test, group_train, group_test <span class="op">=</span> train_test_split(</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    features, label, group, test_size<span class="op">=</span><span class="fl">0.2</span>, random_state<span class="op">=</span><span class="dv">0</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>For later analysis, we create a function that modifies our training and testing datasets, which only include the training features. We add both the group (race) and label (employment status) columns to the new dataset as well as modify encoded labels to labels that we can understand. For the sake of analyzing sufficiently large racial groups, we sort groups into White, African American, Asian, and Other.</p>
<div id="cell-11" class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> format_data(df, features_to_use, group, labels):</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    new_df <span class="op">=</span> pd.DataFrame(df, columns <span class="op">=</span> features_to_use)</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    new_df[<span class="st">'group'</span>] <span class="op">=</span> group</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    new_df[<span class="st">'employed'</span>] <span class="op">=</span> labels</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    new_df[<span class="st">'SEX'</span>] <span class="op">=</span> new_df[<span class="st">'SEX'</span>].replace({<span class="fl">1.0</span>: <span class="st">'Male'</span>, <span class="fl">2.0</span>: <span class="st">'Female'</span>})</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>    new_df[<span class="st">'group'</span>] <span class="op">=</span> new_df[<span class="st">'group'</span>].replace({<span class="fl">1.0</span>: <span class="st">'White'</span>, </span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>                                               <span class="fl">2.0</span>: <span class="st">'African American'</span>,</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>                                               <span class="fl">3.0</span>: <span class="st">'Other Race'</span>,</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>                                               <span class="fl">4.0</span>: <span class="st">'Other Race'</span>,</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>                                               <span class="fl">5.0</span>: <span class="st">'Other Race'</span>,</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>                                               <span class="fl">6.0</span>: <span class="st">'Asian'</span>,</span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>                                               <span class="fl">7.0</span>: <span class="st">'Other Race'</span>,</span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>                                               <span class="fl">8.0</span>: <span class="st">'Other Race'</span>,</span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>                                               <span class="fl">9.0</span>: <span class="st">'Other Race'</span>})</span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> new_df</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>A quick examination of the training data shows that each of our racial groups are in the same order of magnitude with the exception of the White group, which has significantly more people in it.</p>
<div id="cell-13" class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>df_train <span class="op">=</span> format_data(X_train, features_to_use, group_train, y_train)</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>df_train.groupby(<span class="st">'group'</span>).size()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="7">
<pre><code>group
African American     19200
Asian                13633
Other Race           13904
White               110836
dtype: int64</code></pre>
</div>
</div>
<p>Using this dataframe, we can determine the population of the training dataset, which we find to be <span class="math inline">\(157573\)</span> people.</p>
<div id="cell-15" class="cell" data-execution_count="8">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>population <span class="op">=</span> df_train.shape[<span class="dv">0</span>]</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>population</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="8">
<pre><code>157573</code></pre>
</div>
</div>
<p>Of these individuals, roughly <span class="math inline">\(46.5\%\)</span> people are employed. This rate is likely so low because we included children in our data, the majority of whom are unemployed.</p>
<div id="cell-17" class="cell" data-execution_count="9">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>df_train[<span class="st">'employed'</span>].mean()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="9">
<pre><code>0.4649400595279648</code></pre>
</div>
</div>
<p>We can also analyze the proportion of each race in our population. As we saw in the population counts above, African Americans, Asians, and Other Racial groups each make up a similar amount of the population with <span class="math inline">\(11.0\%\)</span>, <span class="math inline">\(9.3\%\)</span>, and <span class="math inline">\(7.9\%\)</span> respectively, while White people make up the remaining <span class="math inline">\(71.8\%\)</span> of the population.</p>
<div id="cell-19" class="cell" data-execution_count="10">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>df_train[df_train[<span class="st">'employed'</span>] <span class="op">==</span> <span class="dv">1</span>].groupby(<span class="st">'group'</span>).size()<span class="op">/</span>df_train[df_train[<span class="st">'employed'</span>] <span class="op">==</span> <span class="dv">1</span>].shape[<span class="dv">0</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="10">
<pre><code>group
African American    0.109607
Asian               0.092517
Other Race          0.079277
White               0.718599
dtype: float64</code></pre>
</div>
</div>
<p>Despite variances in the size of each racial group, we observe roughly equal employment rates across groups such that <span class="math inline">\(41.8\%\)</span> of African Americans are employed, <span class="math inline">\(49.7\%\)</span> of Asians are employed, <span class="math inline">\(47.5\%\)</span> of Whites are employed, and <span class="math inline">\(41.8\%\)</span> of individuals in other racial groups are employed. These values will be important later for when we audit our model to determine how consistent the predicted employment rates are with reality.</p>
<div id="cell-21" class="cell" data-execution_count="11">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>df_train.groupby(<span class="st">'group'</span>)[<span class="st">'employed'</span>].mean()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="11">
<pre><code>group
African American    0.418229
Asian               0.497176
Other Race          0.417722
White               0.474990
Name: employed, dtype: float64</code></pre>
</div>
</div>
<p>It is also worth checking for intersectional trends by examining what percentage of people are employed grouped by sex as well as race. This can help us determine if race is the only major factor in disparities between groups or if there are other contributing factors. Based on the bar plot below, it appears that a greater proportion of men than women are employed with the exception of the African American group. This indicates that women within each racial group may receive further bias from the algorithm, as it is possible that it will predict unemployment for women at higher rates. This may be more prevalent than bias by race since sex is actually a feature that we give to the model wheras race is not.</p>
<div id="cell-23" class="cell" data-execution_count="27">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> seaborn <span class="im">as</span> sns</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> seaborn.objects <span class="im">as</span> so</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>prop <span class="op">=</span> (df_train[df_train[<span class="st">'employed'</span>] <span class="op">==</span> <span class="dv">1</span>].groupby([<span class="st">'group'</span>, <span class="st">'SEX'</span>]).size()<span class="op">/</span>df_train.groupby([<span class="st">'group'</span>, <span class="st">'SEX'</span>]).size()).reset_index(name <span class="op">=</span> <span class="st">'p'</span>)</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>p1 <span class="op">=</span> sns.barplot(data <span class="op">=</span> prop,</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>                 x <span class="op">=</span> <span class="st">'group'</span>,</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>                 y <span class="op">=</span> <span class="st">'p'</span>,</span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>                 hue <span class="op">=</span> <span class="st">'SEX'</span>,</span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>                 palette<span class="op">=</span><span class="st">'Set2'</span>)</span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>p1.<span class="bu">set</span>(title <span class="op">=</span> <span class="st">'Intersection between race and sex'</span>, xlabel <span class="op">=</span> <span class="st">'Race'</span>, ylabel <span class="op">=</span> <span class="st">'Proportion of group employed'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="27">
<pre><code>[Text(0.5, 1.0, 'Intersection between race and sex'),
 Text(0.5, 0, 'Race'),
 Text(0, 0.5, 'Proportion of group employed')]</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/cell-12-output-2.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="fitting-a-model" class="level1">
<h1>Fitting a Model</h1>
<p>Now to train our model. We have chosen to use a Decision Tree Classifer Model. We use the Standard Scaler to make sure each of our features are weighted equally when training our model.</p>
<div id="cell-25" class="cell" data-execution_count="13">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.tree <span class="im">import</span> DecisionTreeClassifier</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.model_selection <span class="im">import</span> cross_val_score</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.pipeline <span class="im">import</span> make_pipeline</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.preprocessing <span class="im">import</span> StandardScaler</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>In order to use Decision Tree Classifier, we need to tune the max_depth parameter. We can do this very elegantly by trying every possible depth from <span class="math inline">\(1\)</span> to <span class="math inline">\(100\)</span> and choosing the model which scores the most accurately on the data. From this approach, we find that the optimal depth is <span class="math inline">\(10\)</span>. Nice!</p>
<div id="cell-27" class="cell" data-execution_count="14">
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>max_depths <span class="op">=</span> np.linspace(<span class="dv">1</span>, <span class="dv">100</span>, <span class="dv">100</span>)</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>best_depth <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>best_val <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>best_model <span class="op">=</span> DecisionTreeClassifier(max_depth <span class="op">=</span> <span class="dv">1</span>)</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> depth <span class="kw">in</span> max_depths:</span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>    DTC <span class="op">=</span> make_pipeline(StandardScaler(), DecisionTreeClassifier(max_depth <span class="op">=</span> <span class="bu">int</span>(depth)))</span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>    DTC.fit(X_train, y_train)</span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>    val <span class="op">=</span> cross_val_score(DTC, X_train, y_train, cv <span class="op">=</span> <span class="dv">5</span>).mean()</span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> val <span class="op">&gt;</span> best_val:</span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a>        best_val <span class="op">=</span> val</span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a>        best_depth <span class="op">=</span> depth</span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a>        best_model <span class="op">=</span> DTC</span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Best Depth: </span><span class="sc">{}</span><span class="st">"</span>.<span class="bu">format</span>(best_depth))</span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true" tabindex="-1"></a></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Best Depth: 10.0</code></pre>
</div>
</div>
</section>
<section id="auditing-the-model" class="level1">
<h1>Auditing the model</h1>
<p>Now that we’ve trained our model, we want to audit our model for implicit biases that it may have picked up from the data. We can first examine some overall features of the model and then examine those features by group to see where differences may be occuring. ## Overall Measures We can first format our data as we did with the training set and then calculat ethe prediction accuracy. Our model appears to guess employment status correctly <span class="math inline">\(82.4\%\)</span> of the time.</p>
<div id="cell-29" class="cell" data-execution_count="15">
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> format_data(X_test, features_to_use, group_test, y_test)</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>df[<span class="st">'pred_employed'</span>] <span class="op">=</span> best_model.predict(X_test)</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>df[<span class="st">'correct_prediction'</span>] <span class="op">=</span> (df[<span class="st">'employed'</span>] <span class="op">==</span> df[<span class="st">'pred_employed'</span>])</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Prediction Accuracy</span></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>df[<span class="st">'correct_prediction'</span>].mean()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="15">
<pre><code>0.8237802711072753</code></pre>
</div>
</div>
<p>To break down where the model went wrong, we can exmaine the number of correct positive and negative predictions as well as incorrect positive and negative predictions. It appears that our model tends to incorrectly guess that a given employee is employed rather than unemployed, indicated by the <span class="math inline">\(4474\)</span> false positive (FP) guesses and the <span class="math inline">\(2472\)</span> false negative (FN) guesses.</p>
<div id="cell-31" class="cell" data-execution_count="16">
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>df[<span class="st">'TN'</span>] <span class="op">=</span> (df[<span class="st">'employed'</span>] <span class="op">==</span> <span class="dv">0</span>) <span class="op">&amp;</span> (df[<span class="st">'pred_employed'</span>] <span class="op">==</span> <span class="dv">0</span>)</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>df[<span class="st">'TP'</span>] <span class="op">=</span> (df[<span class="st">'employed'</span>] <span class="op">==</span> <span class="dv">1</span>) <span class="op">&amp;</span> (df[<span class="st">'pred_employed'</span>] <span class="op">==</span> <span class="dv">1</span>)</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>df[<span class="st">'FN'</span>] <span class="op">=</span> (df[<span class="st">'employed'</span>] <span class="op">==</span> <span class="dv">1</span>) <span class="op">&amp;</span> (df[<span class="st">'pred_employed'</span>] <span class="op">==</span> <span class="dv">0</span>)</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>df[<span class="st">'FP'</span>] <span class="op">=</span> (df[<span class="st">'employed'</span>] <span class="op">==</span> <span class="dv">0</span>) <span class="op">&amp;</span> (df[<span class="st">'pred_employed'</span>] <span class="op">==</span> <span class="dv">1</span>)</span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>df[[<span class="st">'TN'</span>, <span class="st">'TP'</span>, <span class="st">'FN'</span>, <span class="st">'FP'</span>]].<span class="bu">sum</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="16">
<pre><code>TN    16719
TP    15733
FN     2474
FP     4468
dtype: int64</code></pre>
</div>
</div>
<p>Using these values we can calculate the positive predictive value (PPV), which is defined by <span class="math display">\[PPV = \frac{TP}{TP + FP}\]</span> as well as the false positive rate <span class="math display">\[FPR = \frac{FP}{FP + TN}\]</span> and false negative rate <span class="math display">\[FNR = \frac{FN}{FN + TP}\]</span>. We find these values to be <span class="math inline">\(77.9\%\)</span>, <span class="math inline">\(21.1\%\)</span>, and <span class="math inline">\(13.6\%\)</span> respectively.</p>
<div id="cell-33" class="cell" data-execution_count="17">
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>PPV <span class="op">=</span> df[<span class="st">'TP'</span>].<span class="bu">sum</span>() <span class="op">/</span> (df[<span class="st">'TP'</span>].<span class="bu">sum</span>() <span class="op">+</span> df[<span class="st">'FP'</span>].<span class="bu">sum</span>())</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>FPR <span class="op">=</span> df[<span class="st">'FP'</span>].<span class="bu">sum</span>()<span class="op">/</span>(df[<span class="st">'FP'</span>].<span class="bu">sum</span>() <span class="op">+</span> df[<span class="st">'TN'</span>].<span class="bu">sum</span>())</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>FNR <span class="op">=</span> df[<span class="st">'FN'</span>].<span class="bu">sum</span>()<span class="op">/</span>(df[<span class="st">'FN'</span>].<span class="bu">sum</span>() <span class="op">+</span> df[<span class="st">'TP'</span>].<span class="bu">sum</span>())</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(PPV, FPR, FNR)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>0.7788228305529429 0.21088403266153774 0.13588180370187292</code></pre>
</div>
</div>
<section id="by-group-measures" class="level2">
<h2 class="anchored" data-anchor-id="by-group-measures">By-Group Measures</h2>
<p>We can now look at the same quantities as above but sorted by group. Starting with accuracy, we notice that the model seems to be fairly consistent in its predictions with the exception of Asians who are only predicted correctly <span class="math inline">\(80.0\%\)</span> of the time compares to the other groups who are predicted correctly roughly <span class="math inline">\(82\%\)</span> of the time.</p>
<div id="cell-35" class="cell" data-execution_count="18">
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>df.groupby(<span class="st">"group"</span>)[<span class="st">'correct_prediction'</span>].mean()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="18">
<pre><code>group
African American    0.820896
Asian               0.795996
Other Race          0.831117
White               0.826760
Name: correct_prediction, dtype: float64</code></pre>
</div>
</div>
<p>We calculate the positive and negative counts as by group as well, which we will need for our PPV, FPR, and FNR values.</p>
<div id="cell-37" class="cell" data-execution_count="19">
<div class="sourceCode cell-code" id="cb31"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>df.groupby(<span class="st">'group'</span>)[[<span class="st">'TP'</span>, <span class="st">'TN'</span>, <span class="st">'FP'</span>, <span class="st">'FN'</span>]].<span class="bu">sum</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="19">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">TP</th>
<th data-quarto-table-cell-role="th">TN</th>
<th data-quarto-table-cell-role="th">FP</th>
<th data-quarto-table-cell-role="th">FN</th>
</tr>
<tr class="even">
<th data-quarto-table-cell-role="th">group</th>
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">African American</td>
<td>1800</td>
<td>2160</td>
<td>574</td>
<td>290</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">Asian</td>
<td>1539</td>
<td>1165</td>
<td>537</td>
<td>156</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">Other Race</td>
<td>1290</td>
<td>1648</td>
<td>402</td>
<td>195</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">White</td>
<td>11104</td>
<td>11746</td>
<td>2955</td>
<td>1833</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>Calculating the PPVs, we find that the values are fairly consistent with the White group having the highest value of <span class="math inline">\(79.0\%\)</span> and the Asian group having the lowest predictive value of <span class="math inline">\(74.1\%\)</span>. This means that <span class="math inline">\(79.0\%\)</span> of the White people that are predicted to be employed are actually employed and <span class="math inline">\(74.1\%\)</span> of the Asian people that are predicted to be employed are actually employed.</p>
<div id="cell-39" class="cell" data-execution_count="20">
<div class="sourceCode cell-code" id="cb32"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>PPV <span class="op">=</span> df.groupby(<span class="st">'group'</span>)[<span class="st">'TP'</span>].<span class="bu">sum</span>() <span class="op">/</span> (df.groupby(<span class="st">'group'</span>)[<span class="st">'TP'</span>].<span class="bu">sum</span>() <span class="op">+</span> df.groupby(<span class="st">'group'</span>)[<span class="st">'FP'</span>].<span class="bu">sum</span>())</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>PPV</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="20">
<pre><code>group
African American    0.758214
Asian               0.741329
Other Race          0.762411
White               0.789814
dtype: float64</code></pre>
</div>
</div>
<p>Calculating the FPR, we find that Asians are falsly predicted to be employed at a much higher rate than other groups with an FPR of <span class="math inline">\(31.6\%\)</span>. The reamining groups all have FPR values of roughly <span class="math inline">\(20\%\)</span>, indicating that our model may have a bias towards the Asian group.</p>
<div id="cell-41" class="cell" data-execution_count="21">
<div class="sourceCode cell-code" id="cb34"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>FPR <span class="op">=</span> df.groupby(<span class="st">'group'</span>)[<span class="st">'FP'</span>].<span class="bu">sum</span>()<span class="op">/</span>(df.groupby(<span class="st">'group'</span>)[<span class="st">'FP'</span>].<span class="bu">sum</span>() <span class="op">+</span> df.groupby(<span class="st">'group'</span>)[<span class="st">'TN'</span>].<span class="bu">sum</span>())</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>FPR</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="21">
<pre><code>group
African American    0.209949
Asian               0.315511
Other Race          0.196098
White               0.201007
dtype: float64</code></pre>
</div>
</div>
<p>The FNR rates closely resemble the trends seen in the FPR values, with each group having a value of roughly <span class="math inline">\(13.5\%\)</span> with the exception fo the Asian group, which has an FNR of <span class="math inline">\(9.2\%\)</span>. This reinforces our observation that the model tends to overestimate the employment rate of the Asian group relative to the other groups.</p>
<div id="cell-43" class="cell" data-execution_count="22">
<div class="sourceCode cell-code" id="cb36"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>FNR <span class="op">=</span> df.groupby(<span class="st">'group'</span>)[<span class="st">'FN'</span>].<span class="bu">sum</span>()<span class="op">/</span>(df.groupby(<span class="st">'group'</span>)[<span class="st">'FN'</span>].<span class="bu">sum</span>() <span class="op">+</span> df.groupby(<span class="st">'group'</span>)[<span class="st">'TP'</span>].<span class="bu">sum</span>())</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>FNR</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="22">
<pre><code>group
African American    0.138756
Asian               0.092035
Other Race          0.131313
White               0.141687
dtype: float64</code></pre>
</div>
</div>
</section>
<section id="bias-measures" class="level2">
<h2 class="anchored" data-anchor-id="bias-measures">Bias Measures</h2>
<p>In order to check for bias, we can evaluate our model based on three standards: calibration, error rate balance, and statistical parity.</p>
<p>We can first examine calibration. A model is well calibrated if the prediction rates are consistent with the actual rates across racial groups. If we were to exclude the Asian group, we could say that our model is approximately calibrated. However, the Asian group has a significantly higher prediction rate than actual rate of employment, indicating poor calibration.</p>
<div id="cell-45" class="cell" data-execution_count="23">
<div class="sourceCode cell-code" id="cb38"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Calibration</span></span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>employed <span class="op">=</span> df.groupby(<span class="st">'group'</span>)[<span class="st">'employed'</span>].mean()</span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>predicted_employed <span class="op">=</span> df.groupby(<span class="st">'group'</span>)[<span class="st">'pred_employed'</span>].mean()</span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a>pd.concat((predicted_employed, employed), axis <span class="op">=</span> <span class="dv">1</span>, keys <span class="op">=</span> [<span class="st">'Prediction'</span>, <span class="st">'True Rate'</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="23">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">Prediction</th>
<th data-quarto-table-cell-role="th">True Rate</th>
</tr>
<tr class="even">
<th data-quarto-table-cell-role="th">group</th>
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">African American</td>
<td>0.492123</td>
<td>0.433250</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">Asian</td>
<td>0.611127</td>
<td>0.498970</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">Other Race</td>
<td>0.478642</td>
<td>0.420085</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">White</td>
<td>0.508684</td>
<td>0.468087</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>Next we examine error rate parity, which evaluates if the FPR and FNR values are consistent with one another across groups. As with the calibration, three of the groups are fairly consistent with their FPR and FNR values, while the Asian group has a substantially higher FPR and a substantially lower FNR, indicating a poor error rate parity as well.</p>
<div id="cell-47" class="cell" data-execution_count="24">
<div class="sourceCode cell-code" id="cb39"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Error Rate Parity</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>pd.concat((FPR, FNR), axis <span class="op">=</span> <span class="dv">1</span>, keys <span class="op">=</span> [<span class="st">'FPR'</span>, <span class="st">'FNR'</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="24">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">FPR</th>
<th data-quarto-table-cell-role="th">FNR</th>
</tr>
<tr class="even">
<th data-quarto-table-cell-role="th">group</th>
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">African American</td>
<td>0.209949</td>
<td>0.138756</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">Asian</td>
<td>0.315511</td>
<td>0.092035</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">Other Race</td>
<td>0.196098</td>
<td>0.131313</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">White</td>
<td>0.201007</td>
<td>0.141687</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>Lastly we can check for statistical parity, which examines if the predicted employment rates between groups are equal to one another. A model that satisfies statistical parity would have an equal proportion of people predicted to be employed across each group. Our model also does not satisfy statistical parity, as the predicted rate of Asian employment is signficantly higher than the rate for the three other racial groups.</p>
<div id="cell-49" class="cell" data-execution_count="25">
<div class="sourceCode cell-code" id="cb40"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Statistical Parity </span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>df.groupby(<span class="st">'group'</span>)[<span class="st">'pred_employed'</span>].mean()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="25">
<pre><code>group
African American    0.492123
Asian               0.611127
Other Race          0.478642
White               0.508684
Name: pred_employed, dtype: float64</code></pre>
</div>
</div>
<p>Based on the paper “Fair Prediction with Disparate Impact: A Study of Bias in Recidivism Prediction Instruments.” by Alexandra Chouldechova, we can examine how fair our model has the potential to be by finding the optimal combinations of FNR and FPR rates. We can calculate the FPR using the FNR with the equation <span class="math display">\[FPR = \frac{p}{1 - p}\frac{1 - PPV}{PPV}(1 - FNR)\]</span> where <span class="math inline">\(p\)</span> is the prevalence or actual employment rate. As an approximation to calibrate our results, we set the PPV to be the minimum PPV value between groups. In this case, we are only examining the White and Asian groups, so we use the Asian PPV as our value. We can add shading to the White line, which shows acceptable FPR values for the White group if we allow the the PPV of the White group to deviate by <span class="math inline">\(\delta = 0.5\)</span>, <span class="math inline">\(0.1\)</span>, and <span class="math inline">\(0.125\)</span> from the PPV of the Asian group. Based on the plot, if we desired to tune our classifier threshold so that the false positive rates were equal between races, we would need to increase the false negative rate of the Asian group to roughly <span class="math inline">\(0.2\)</span>. This is not a substantial change, indicating that we could achieve a fair outcome without much of a decrease in the accuracy of the model.</p>
<div id="cell-51" class="cell" data-execution_count="26">
<div class="sourceCode cell-code" id="cb42"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a>PPV_min <span class="op">=</span> PPV[[<span class="st">'Asian'</span>, <span class="st">'White'</span>]].<span class="bu">min</span>()</span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a>p <span class="op">=</span> df.groupby(<span class="st">'group'</span>)[<span class="st">'employed'</span>].mean()</span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a>FNR_calc <span class="op">=</span> np.linspace(<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">50</span>)</span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a>FPR_calc <span class="op">=</span> <span class="kw">lambda</span> p,FNR, PPV_min: (p<span class="op">/</span>(<span class="dv">1</span><span class="op">-</span>p)) <span class="op">*</span> ((<span class="dv">1</span> <span class="op">-</span> PPV_min)<span class="op">/</span>PPV_min)<span class="op">*</span>(<span class="dv">1</span> <span class="op">-</span> FNR)</span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a>FPRs <span class="op">=</span> [FPR_calc(ps, FNR_calc, PPV_min) <span class="cf">for</span> ps <span class="kw">in</span> p]</span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, FPR <span class="kw">in</span> <span class="bu">enumerate</span>(FPRs):</span>
<span id="cb42-8"><a href="#cb42-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(p.index[i] <span class="kw">in</span> [<span class="st">'Asian'</span>, <span class="st">'White'</span>]):</span>
<span id="cb42-9"><a href="#cb42-9" aria-hidden="true" tabindex="-1"></a>        plt.plot(FNR_calc, FPR, label <span class="op">=</span> p.index[i])</span>
<span id="cb42-10"><a href="#cb42-10" aria-hidden="true" tabindex="-1"></a>        plt.scatter(FNR[i], FPR[i])</span>
<span id="cb42-11"><a href="#cb42-11" aria-hidden="true" tabindex="-1"></a>plt.fill_between(FNR_calc, FPR_calc(p[<span class="st">'White'</span>], FNR_calc, PPV_min <span class="op">-</span><span class="fl">0.05</span>),FPR_calc(p[<span class="st">'White'</span>], FNR_calc, PPV_min <span class="op">+</span><span class="fl">0.05</span>), alpha <span class="op">=</span> <span class="fl">0.1</span>)</span>
<span id="cb42-12"><a href="#cb42-12" aria-hidden="true" tabindex="-1"></a>plt.fill_between(FNR_calc, FPR_calc(p[<span class="st">'White'</span>], FNR_calc, PPV_min <span class="op">-</span><span class="fl">0.1</span>),FPR_calc(p[<span class="st">'White'</span>], FNR_calc, PPV_min <span class="op">+</span><span class="fl">0.1</span>), alpha <span class="op">=</span> <span class="fl">0.2</span>)</span>
<span id="cb42-13"><a href="#cb42-13" aria-hidden="true" tabindex="-1"></a>plt.fill_between(FNR_calc, FPR_calc(p[<span class="st">'White'</span>], FNR_calc, PPV_min <span class="op">-</span><span class="fl">0.125</span>),FPR_calc(p[<span class="st">'White'</span>], FNR_calc, PPV_min <span class="op">+</span><span class="fl">0.125</span>), alpha <span class="op">=</span> <span class="fl">0.4</span>)</span>
<span id="cb42-14"><a href="#cb42-14" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'False Negative Rate'</span>)</span>
<span id="cb42-15"><a href="#cb42-15" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'False Positive Rate'</span>)</span>
<span id="cb42-16"><a href="#cb42-16" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'Feasible (FNR, FPR) Combinations'</span>)</span>
<span id="cb42-17"><a href="#cb42-17" aria-hidden="true" tabindex="-1"></a>plt.legend()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/cell-26-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
</section>
</section>
<section id="conclusion" class="level1">
<h1>Conclusion</h1>
<ol type="1">
<li>The discussion of employment prediction has numerous practical applications that could benefit or harm specific groups. For instance, landlords and bankers may want to be able to use this algorithm to determine whether or not to rent or give a loan to someone, as an employed person would be more likely to be able to make their payments on time.</li>
<li>Based on our bias audit, this could be potentially harmful to certain groups, as we observed that certain groups were predicted to be employed at much higher rates than the other groups and also than the real employment rate. This could provide unfair advantages and disadvantages to specific groups based simply on their race. This is particularly troubling given that the actual rates of employment were fairly consistent between groups. If we were to deploy this on a large scale, our model could potentially enforce inequality between races and make it more difficult for certain groups to obtain necessary resources like a place to live or access to credit.</li>
<li>Based on our bias audit, our model displays problematic bias of all three types, failing to satisfy calibration, error rate balance, and statistical parity. While there was general agreement between three of our groups, our fourth group deviated heavily in all three measurements. If we were to deploy this model on a large scale, we would need to somehow alter our model to account for the disparity with this group.</li>
<li>Besides potential bias, this model has the potential to make decisions that could harm large groups of people. For starters, this model is built on the idea that we can generalize a subset of the population to the entire population based on a very select number of features. This is not necessarily true and could lead to the model making generalizations and decisions about groups based on certain traits that we have not considered. One way we could counteract this is by giving the model more training data and selecting more features to train the model on. The other issue with this model is that the ending result: guessing employment, could very easily be used to make harmful decisions based on unfair assumptions. Based on the renter example, people that are unemployed or perhaps are just predicted to be unemployed could have harder times finding a home, even if they were able to pay their rent on time consistently. A predictive model like this would just make it harder for groups of people that are likely already struggling due to their lack of employment. Because of this, we need to be very careful when implementing decision-making algorithms on a large scale.</li>
</ol>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>