<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.40">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Omar Armbruster">
<meta name="dcterms.date" content="2025-02-26">
<meta name="description" content="Borrowers v. Bankers: A case study in maximizing shareholder value">

<title>Design and Impact of Automated Decisions – Omar Armbruster</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script><script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-549806ee2085284f45b00abea8c6df48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-afd1c537f28ba892ec3c7a1a10902170.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<style>

      .quarto-title-block .quarto-title-banner h1,
      .quarto-title-block .quarto-title-banner h2,
      .quarto-title-block .quarto-title-banner h3,
      .quarto-title-block .quarto-title-banner h4,
      .quarto-title-block .quarto-title-banner h5,
      .quarto-title-block .quarto-title-banner h6
      {
        color: white;
      }

      .quarto-title-block .quarto-title-banner {
        color: white;
background-image: url(../../img/landscape.png);
background-size: cover;
      }
</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" integrity="sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==" crossorigin="anonymous"></script>

<script type="application/javascript">define('jquery', [],function() {return window.jQuery;})</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Omar Armbruster</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/omar-armbruster"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/omar-armbruster-38951621b/"> <i class="bi bi-linkedin" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Design and Impact of Automated Decisions</h1>
                  <div>
        <div class="description">
          Borrowers v. Bankers: A case study in maximizing shareholder value
        </div>
      </div>
                </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Omar Armbruster </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">February 26, 2025</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<section id="abstract" class="level1">
<h1>Abstract</h1>
<p>This post examines threshold-choosing techniques that allow us to evaluate the efficacy of a classifier outside of the accuracy. Our case examines bank lending where our machine learning model must evaluate if a borrower is likely to default on their loans. In this scenario, it is much more costly for the bank to approve a loan that will be defaulted on than to reject a borrower that would have actually been able to pay back their loan. Because the errors are asymmetric in cost, we can find an optimal threshold for approving and denying loans, which will allow the bank to maximize profits. We use logistic regression on our dataset to find an optimal set of weights and then use the dot product to use these weights to convert our data to a probability that each prosepctive borrower will default. Based on these probabilities, we test a set of thresholds for allowable default risk and select the optimal one that will maximize profit. We find that the optimal threshold rejects any prospective borrower with a risk of default above <span class="math inline">\(58\%\)</span> and results in a profit of roughly <span class="math inline">\(\$ 1400\)</span> per prospective borrower. We also analyze how our threshold impacts different demographics of borrowers.</p>
</section>
<section id="introduction" class="level1">
<h1>Introduction</h1>
<p>To loan or not to loan: That is the question which most often plagues the indecisive banker. For the siren call of unlimited riches in the form of monthly interest payments beckons, but can lead to certain doom for those who make hasty loans that end in default. So the banker is left with a choice: lay down anchor and decry all loans to avoid disaster or set sail into the perilous loan-giving waters in search of the glorious bounty that awaits. Fortunately for today’s bankers, our modern day Prometheus–Big Tech–has bestowed upon us machines, which can make decisions autonomously, providing some solace for those who do not wish to bear the decision-making responsibility alone.</p>
<p>We can train one such machine learning model as follows, beginning by importing our trusty tools NumPy and Pandas as well as our training dataset. Our interest rates are given as percentages, which we will want to convert to a decimal for later calculations.</p>
<div id="cell-3" class="cell" data-execution_count="19">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>url <span class="op">=</span> <span class="st">"https://raw.githubusercontent.com/PhilChodrow/ml-notes/main/data/credit-risk/train.csv"</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>df_train <span class="op">=</span> pd.read_csv(url)</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>df_train[<span class="st">'loan_int_rate'</span>] <span class="op">=</span> df_train[<span class="st">"loan_int_rate"</span>]<span class="op">/</span><span class="dv">100</span> <span class="co"># Convert percentage to decimal</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>df_train.head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="19">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">person_age</th>
<th data-quarto-table-cell-role="th">person_income</th>
<th data-quarto-table-cell-role="th">person_home_ownership</th>
<th data-quarto-table-cell-role="th">person_emp_length</th>
<th data-quarto-table-cell-role="th">loan_intent</th>
<th data-quarto-table-cell-role="th">loan_grade</th>
<th data-quarto-table-cell-role="th">loan_amnt</th>
<th data-quarto-table-cell-role="th">loan_int_rate</th>
<th data-quarto-table-cell-role="th">loan_status</th>
<th data-quarto-table-cell-role="th">loan_percent_income</th>
<th data-quarto-table-cell-role="th">cb_person_default_on_file</th>
<th data-quarto-table-cell-role="th">cb_person_cred_hist_length</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>25</td>
<td>43200</td>
<td>RENT</td>
<td>NaN</td>
<td>VENTURE</td>
<td>B</td>
<td>1200</td>
<td>0.0991</td>
<td>0</td>
<td>0.03</td>
<td>N</td>
<td>4</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>27</td>
<td>98000</td>
<td>RENT</td>
<td>3.0</td>
<td>EDUCATION</td>
<td>C</td>
<td>11750</td>
<td>0.1347</td>
<td>0</td>
<td>0.12</td>
<td>Y</td>
<td>6</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>22</td>
<td>36996</td>
<td>RENT</td>
<td>5.0</td>
<td>EDUCATION</td>
<td>A</td>
<td>10000</td>
<td>0.0751</td>
<td>0</td>
<td>0.27</td>
<td>N</td>
<td>4</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>24</td>
<td>26000</td>
<td>RENT</td>
<td>2.0</td>
<td>MEDICAL</td>
<td>C</td>
<td>1325</td>
<td>0.1287</td>
<td>1</td>
<td>0.05</td>
<td>N</td>
<td>4</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>29</td>
<td>53004</td>
<td>MORTGAGE</td>
<td>2.0</td>
<td>HOMEIMPROVEMENT</td>
<td>A</td>
<td>15000</td>
<td>0.0963</td>
<td>0</td>
<td>0.28</td>
<td>N</td>
<td>10</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>We preprocess the data in a way that can be read by our machine by converting our categorical columns into dummy columns and dropping NA values. We also separate our target variable “loan_status”, which is a <span class="math inline">\(1\)</span> if the borrower defaulted and a <span class="math inline">\(0\)</span> if the borrower paid back their loan. “loan_grade” is a measurement from the bank that determines the likelyhood that the loan is paid back. We want to remove this as well, as the goal is for our model to not be under the influence of outside evaluation methods.</p>
<div id="cell-5" class="cell" data-execution_count="20">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> preprocess_data(df):</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    df <span class="op">=</span> df.dropna()</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    y_train <span class="op">=</span> df[<span class="st">"loan_status"</span>]</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    df <span class="op">=</span> df.drop([<span class="st">"loan_status"</span>, <span class="st">"loan_grade"</span>], axis <span class="op">=</span> <span class="dv">1</span>)</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    df <span class="op">=</span> pd.get_dummies(df)</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> df, y_train</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>X_train, y_train <span class="op">=</span> preprocess_data(df_train)</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>X_train.head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="20">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">person_age</th>
<th data-quarto-table-cell-role="th">person_income</th>
<th data-quarto-table-cell-role="th">person_emp_length</th>
<th data-quarto-table-cell-role="th">loan_amnt</th>
<th data-quarto-table-cell-role="th">loan_int_rate</th>
<th data-quarto-table-cell-role="th">loan_percent_income</th>
<th data-quarto-table-cell-role="th">cb_person_cred_hist_length</th>
<th data-quarto-table-cell-role="th">person_home_ownership_MORTGAGE</th>
<th data-quarto-table-cell-role="th">person_home_ownership_OTHER</th>
<th data-quarto-table-cell-role="th">person_home_ownership_OWN</th>
<th data-quarto-table-cell-role="th">person_home_ownership_RENT</th>
<th data-quarto-table-cell-role="th">loan_intent_DEBTCONSOLIDATION</th>
<th data-quarto-table-cell-role="th">loan_intent_EDUCATION</th>
<th data-quarto-table-cell-role="th">loan_intent_HOMEIMPROVEMENT</th>
<th data-quarto-table-cell-role="th">loan_intent_MEDICAL</th>
<th data-quarto-table-cell-role="th">loan_intent_PERSONAL</th>
<th data-quarto-table-cell-role="th">loan_intent_VENTURE</th>
<th data-quarto-table-cell-role="th">cb_person_default_on_file_N</th>
<th data-quarto-table-cell-role="th">cb_person_default_on_file_Y</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">1</td>
<td>27</td>
<td>98000</td>
<td>3.0</td>
<td>11750</td>
<td>0.1347</td>
<td>0.12</td>
<td>6</td>
<td>False</td>
<td>False</td>
<td>False</td>
<td>True</td>
<td>False</td>
<td>True</td>
<td>False</td>
<td>False</td>
<td>False</td>
<td>False</td>
<td>False</td>
<td>True</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">2</td>
<td>22</td>
<td>36996</td>
<td>5.0</td>
<td>10000</td>
<td>0.0751</td>
<td>0.27</td>
<td>4</td>
<td>False</td>
<td>False</td>
<td>False</td>
<td>True</td>
<td>False</td>
<td>True</td>
<td>False</td>
<td>False</td>
<td>False</td>
<td>False</td>
<td>True</td>
<td>False</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">3</td>
<td>24</td>
<td>26000</td>
<td>2.0</td>
<td>1325</td>
<td>0.1287</td>
<td>0.05</td>
<td>4</td>
<td>False</td>
<td>False</td>
<td>False</td>
<td>True</td>
<td>False</td>
<td>False</td>
<td>False</td>
<td>True</td>
<td>False</td>
<td>False</td>
<td>True</td>
<td>False</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">4</td>
<td>29</td>
<td>53004</td>
<td>2.0</td>
<td>15000</td>
<td>0.0963</td>
<td>0.28</td>
<td>10</td>
<td>True</td>
<td>False</td>
<td>False</td>
<td>False</td>
<td>False</td>
<td>False</td>
<td>True</td>
<td>False</td>
<td>False</td>
<td>False</td>
<td>True</td>
<td>False</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">6</td>
<td>21</td>
<td>21700</td>
<td>2.0</td>
<td>5500</td>
<td>0.1491</td>
<td>0.25</td>
<td>2</td>
<td>False</td>
<td>False</td>
<td>False</td>
<td>True</td>
<td>False</td>
<td>False</td>
<td>True</td>
<td>False</td>
<td>False</td>
<td>False</td>
<td>True</td>
<td>False</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
</section>
<section id="exploring-the-data" class="level1">
<h1>Exploring The Data</h1>
<div id="cell-7" class="cell" data-execution_count="21">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> seaborn <span class="im">as</span> sns</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Our model is only as good as the data it is trained on, and as such, it is important for us to gain a strong understanding of our data before beginning the training process. The scatterplot on the left examines the relationship between two continuous features: “loan_percent_income” and “loan_int_rate”, representing the percentage of the borrower’s income that the requested loan consitutes and the the interest rate of the loan, respectively. Based on the scatterplot–which is colored by if the borrower defaulted–it appears that as both variables increase, the rate of default also increases.</p>
<p>The barplot to the right examines the homeowner status of borrowers and the rate at which each of those groups default on their loans. Borrowers who were renters and had a status of “Other” had the highest rates of default at around <span class="math inline">\(30\%\)</span>, while borrowers who had a mortgage or owned their homes had lower default rates of around <span class="math inline">\(12\%\)</span> and <span class="math inline">\(9\%\)</span>, respectively.</p>
<div id="cell-9" class="cell" data-execution_count="22">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>, figsize <span class="op">=</span> (<span class="dv">8</span>, <span class="dv">4</span>))</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>plt.subplots_adjust(left<span class="op">=</span><span class="fl">0.1</span>, right<span class="op">=</span><span class="fl">0.9</span>, top<span class="op">=</span><span class="fl">0.9</span>, bottom<span class="op">=</span><span class="fl">0.1</span>, wspace<span class="op">=</span><span class="fl">0.3</span>, hspace<span class="op">=</span><span class="fl">0.4</span>)</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>p1 <span class="op">=</span> sns.scatterplot(df_train, x <span class="op">=</span> <span class="st">"loan_percent_income"</span>, y <span class="op">=</span> <span class="st">"loan_int_rate"</span>, hue <span class="op">=</span> <span class="st">"loan_status"</span>, ax <span class="op">=</span> ax[<span class="dv">0</span>])</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>p2 <span class="op">=</span> sns.barplot(df_train, x <span class="op">=</span> <span class="st">"person_home_ownership"</span>, y <span class="op">=</span> <span class="st">"loan_status"</span>, ax <span class="op">=</span> ax[<span class="dv">1</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/cell-5-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Using the table below, we can examine the outcomes for groups with varying intents for their loans. It appears that on average, the interest rate granted by the bank was around <span class="math inline">\(11\%\)</span>, regardless of what the intent was for the loan. Venture loans had the lowest rate of default with a mean of <span class="math inline">\(14.9\%\)</span> while debt consolidation loans had the highest rate of default with a mean of <span class="math inline">\(28.7\%\)</span>.</p>
<div id="cell-11" class="cell" data-execution_count="23">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>df_train.groupby([<span class="st">'loan_intent'</span>]).aggregate({<span class="st">'loan_int_rate'</span>: [<span class="st">'mean'</span>, <span class="st">'std'</span>],</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>                                             <span class="st">'loan_status'</span>: [<span class="st">'mean'</span>, <span class="st">'std'</span>]})</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="23">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th colspan="2" data-quarto-table-cell-role="th" data-halign="left">loan_int_rate</th>
<th colspan="2" data-quarto-table-cell-role="th" data-halign="left">loan_status</th>
</tr>
<tr class="even">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">mean</th>
<th data-quarto-table-cell-role="th">std</th>
<th data-quarto-table-cell-role="th">mean</th>
<th data-quarto-table-cell-role="th">std</th>
</tr>
<tr class="header">
<th data-quarto-table-cell-role="th">loan_intent</th>
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">DEBTCONSOLIDATION</td>
<td>0.109833</td>
<td>0.032782</td>
<td>0.287458</td>
<td>0.452631</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">EDUCATION</td>
<td>0.109655</td>
<td>0.031817</td>
<td>0.173396</td>
<td>0.378626</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">HOMEIMPROVEMENT</td>
<td>0.111601</td>
<td>0.033750</td>
<td>0.264645</td>
<td>0.441220</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">MEDICAL</td>
<td>0.110519</td>
<td>0.032451</td>
<td>0.263289</td>
<td>0.440463</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">PERSONAL</td>
<td>0.110098</td>
<td>0.032337</td>
<td>0.193739</td>
<td>0.395271</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">VENTURE</td>
<td>0.109409</td>
<td>0.032190</td>
<td>0.148678</td>
<td>0.355809</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
</section>
<section id="building-the-model" class="level1">
<h1>Building The Model</h1>
<p>This is where the fun begins: we can now build a model that will help us make loans that optimize our profits. We’ve chosen ol’ reliable–Logistic Regression–as our model, which we can fit to a subset of the features in our data. “But which features?” you may be wondering. Great question! We can determine an ideal combination of features through a trial-and-error like process by fitting a model to different combinations of features and then performing cross-validation on each to determine which set will perform well on a new testing dataset. We define a function getCols() below to make sure all of our relevant categorical dummies are selected when choosing our features.</p>
<div id="cell-14" class="cell" data-execution_count="24">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.model_selection <span class="im">import</span> cross_val_score</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.linear_model <span class="im">import</span> LogisticRegression</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> getCols(X, quant_cols, qual_cols):</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>  cols <span class="op">=</span> quant_cols</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> qual <span class="kw">in</span> qual_cols: </span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>    expand_qual_cols <span class="op">=</span> [col <span class="cf">for</span> col <span class="kw">in</span> X.columns <span class="cf">if</span> qual <span class="kw">in</span> col ]</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>    cols <span class="op">=</span> np.concatenate((cols, expand_qual_cols))</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> cols</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Our first combination of features uses both of the categorical variables we examined in our plots above as well as the interest rate, percentage of the borrowers income that the loan constitutes, the borrower’s age, and the employment length of the borrower’s most recent occupation. Based on our cross-validation test, these features score <span class="math inline">\(84.4\%\)</span>. Nice!</p>
<div id="cell-16" class="cell" data-execution_count="25">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>qual_cols <span class="op">=</span> [<span class="st">'person_home_ownership'</span>, <span class="st">'loan_intent'</span>]</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>quant_cols <span class="op">=</span> [<span class="st">'loan_int_rate'</span>, <span class="st">'loan_percent_income'</span>, <span class="st">'person_age'</span>, <span class="st">'person_emp_length'</span>]</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>cols1 <span class="op">=</span> getCols(X_train, quant_cols, qual_cols)</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>LR <span class="op">=</span> LogisticRegression()</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>LR.fit(X_train[cols1], y_train)</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>cross_val_score(LR, X_train[cols1], y_train, cv <span class="op">=</span> <span class="dv">5</span>).mean()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>c:\Users\omara\.conda\envs\ml451\lib\site-packages\sklearn\linear_model\_logistic.py:460: ConvergenceWarning: lbfgs failed to converge (status=1):
STOP: TOTAL NO. of ITERATIONS REACHED LIMIT.

Increase the number of iterations (max_iter) or scale the data as shown in:
    https://scikit-learn.org/stable/modules/preprocessing.html
Please also refer to the documentation for alternative solver options:
    https://scikit-learn.org/stable/modules/linear_model.html#logistic-regression
  n_iter_i = _check_optimize_result(
c:\Users\omara\.conda\envs\ml451\lib\site-packages\sklearn\linear_model\_logistic.py:460: ConvergenceWarning: lbfgs failed to converge (status=1):
STOP: TOTAL NO. of ITERATIONS REACHED LIMIT.

Increase the number of iterations (max_iter) or scale the data as shown in:
    https://scikit-learn.org/stable/modules/preprocessing.html
Please also refer to the documentation for alternative solver options:
    https://scikit-learn.org/stable/modules/linear_model.html#logistic-regression
  n_iter_i = _check_optimize_result(
c:\Users\omara\.conda\envs\ml451\lib\site-packages\sklearn\linear_model\_logistic.py:460: ConvergenceWarning: lbfgs failed to converge (status=1):
STOP: TOTAL NO. of ITERATIONS REACHED LIMIT.

Increase the number of iterations (max_iter) or scale the data as shown in:
    https://scikit-learn.org/stable/modules/preprocessing.html
Please also refer to the documentation for alternative solver options:
    https://scikit-learn.org/stable/modules/linear_model.html#logistic-regression
  n_iter_i = _check_optimize_result(
c:\Users\omara\.conda\envs\ml451\lib\site-packages\sklearn\linear_model\_logistic.py:460: ConvergenceWarning: lbfgs failed to converge (status=1):
STOP: TOTAL NO. of ITERATIONS REACHED LIMIT.

Increase the number of iterations (max_iter) or scale the data as shown in:
    https://scikit-learn.org/stable/modules/preprocessing.html
Please also refer to the documentation for alternative solver options:
    https://scikit-learn.org/stable/modules/linear_model.html#logistic-regression
  n_iter_i = _check_optimize_result(
c:\Users\omara\.conda\envs\ml451\lib\site-packages\sklearn\linear_model\_logistic.py:460: ConvergenceWarning: lbfgs failed to converge (status=1):
STOP: TOTAL NO. of ITERATIONS REACHED LIMIT.

Increase the number of iterations (max_iter) or scale the data as shown in:
    https://scikit-learn.org/stable/modules/preprocessing.html
Please also refer to the documentation for alternative solver options:
    https://scikit-learn.org/stable/modules/linear_model.html#logistic-regression
  n_iter_i = _check_optimize_result(
c:\Users\omara\.conda\envs\ml451\lib\site-packages\sklearn\linear_model\_logistic.py:460: ConvergenceWarning: lbfgs failed to converge (status=1):
STOP: TOTAL NO. of ITERATIONS REACHED LIMIT.

Increase the number of iterations (max_iter) or scale the data as shown in:
    https://scikit-learn.org/stable/modules/preprocessing.html
Please also refer to the documentation for alternative solver options:
    https://scikit-learn.org/stable/modules/linear_model.html#logistic-regression
  n_iter_i = _check_optimize_result(</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="25">
<pre><code>0.8439336903961869</code></pre>
</div>
</div>
<p>Our second combination ignores all categorical variables and just focuses on the interest rate and the loan’s percentage of the borrower’s income, which could be effective based on the trend we saw in the scatterplot above. We find a cross-validation score of <span class="math inline">\(82.6\%\)</span>. While not as high as the previous combination, the cross-validation score is quite high, indicating a strong predictive power between these two features.</p>
<div id="cell-18" class="cell" data-execution_count="26">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>qual_cols <span class="op">=</span> []</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>quant_cols <span class="op">=</span> [<span class="st">'loan_int_rate'</span>, <span class="st">'loan_percent_income'</span>]</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>cols2 <span class="op">=</span> getCols(X_train, quant_cols, qual_cols)</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>LR <span class="op">=</span> LogisticRegression()</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>LR.fit(X_train[cols2], y_train)</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>cross_val_score(LR, X_train[cols2], y_train, cv <span class="op">=</span> <span class="dv">5</span>).mean()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="26">
<pre><code>0.825773775136919</code></pre>
</div>
</div>
<p>Our last combination uses the same features as the first combination but ignores the loan interest rate and the loan’s percentage of the borrower’s income. Using cross-validation, we get a score of <span class="math inline">\(78.5\%\)</span>.</p>
<div id="cell-20" class="cell" data-execution_count="27">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>qual_cols <span class="op">=</span> [<span class="st">'person_home_ownership'</span>, <span class="st">'loan_intent'</span>]</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>quant_cols <span class="op">=</span> [<span class="st">'person_age'</span>, <span class="st">'person_emp_length'</span>]</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>cols3 <span class="op">=</span> getCols(X_train, quant_cols, qual_cols)</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>LR <span class="op">=</span> LogisticRegression()</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>LR.fit(X_train[cols3], y_train)</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>cross_val_score(LR, X_train[cols3], y_train, cv <span class="op">=</span> <span class="dv">5</span>).mean()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>c:\Users\omara\.conda\envs\ml451\lib\site-packages\sklearn\linear_model\_logistic.py:460: ConvergenceWarning: lbfgs failed to converge (status=1):
STOP: TOTAL NO. of ITERATIONS REACHED LIMIT.

Increase the number of iterations (max_iter) or scale the data as shown in:
    https://scikit-learn.org/stable/modules/preprocessing.html
Please also refer to the documentation for alternative solver options:
    https://scikit-learn.org/stable/modules/linear_model.html#logistic-regression
  n_iter_i = _check_optimize_result(
c:\Users\omara\.conda\envs\ml451\lib\site-packages\sklearn\linear_model\_logistic.py:460: ConvergenceWarning: lbfgs failed to converge (status=1):
STOP: TOTAL NO. of ITERATIONS REACHED LIMIT.

Increase the number of iterations (max_iter) or scale the data as shown in:
    https://scikit-learn.org/stable/modules/preprocessing.html
Please also refer to the documentation for alternative solver options:
    https://scikit-learn.org/stable/modules/linear_model.html#logistic-regression
  n_iter_i = _check_optimize_result(
c:\Users\omara\.conda\envs\ml451\lib\site-packages\sklearn\linear_model\_logistic.py:460: ConvergenceWarning: lbfgs failed to converge (status=1):
STOP: TOTAL NO. of ITERATIONS REACHED LIMIT.

Increase the number of iterations (max_iter) or scale the data as shown in:
    https://scikit-learn.org/stable/modules/preprocessing.html
Please also refer to the documentation for alternative solver options:
    https://scikit-learn.org/stable/modules/linear_model.html#logistic-regression
  n_iter_i = _check_optimize_result(
c:\Users\omara\.conda\envs\ml451\lib\site-packages\sklearn\linear_model\_logistic.py:460: ConvergenceWarning: lbfgs failed to converge (status=1):
STOP: TOTAL NO. of ITERATIONS REACHED LIMIT.

Increase the number of iterations (max_iter) or scale the data as shown in:
    https://scikit-learn.org/stable/modules/preprocessing.html
Please also refer to the documentation for alternative solver options:
    https://scikit-learn.org/stable/modules/linear_model.html#logistic-regression
  n_iter_i = _check_optimize_result(
c:\Users\omara\.conda\envs\ml451\lib\site-packages\sklearn\linear_model\_logistic.py:460: ConvergenceWarning: lbfgs failed to converge (status=1):
STOP: TOTAL NO. of ITERATIONS REACHED LIMIT.

Increase the number of iterations (max_iter) or scale the data as shown in:
    https://scikit-learn.org/stable/modules/preprocessing.html
Please also refer to the documentation for alternative solver options:
    https://scikit-learn.org/stable/modules/linear_model.html#logistic-regression
  n_iter_i = _check_optimize_result(
c:\Users\omara\.conda\envs\ml451\lib\site-packages\sklearn\linear_model\_logistic.py:460: ConvergenceWarning: lbfgs failed to converge (status=1):
STOP: TOTAL NO. of ITERATIONS REACHED LIMIT.

Increase the number of iterations (max_iter) or scale the data as shown in:
    https://scikit-learn.org/stable/modules/preprocessing.html
Please also refer to the documentation for alternative solver options:
    https://scikit-learn.org/stable/modules/linear_model.html#logistic-regression
  n_iter_i = _check_optimize_result(</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="27">
<pre><code>0.7849565667540506</code></pre>
</div>
</div>
<p>While accuracy is not the only consideration to be made when profitmaxxing (as we will get to in a moment), a higher accuracy and cross-validation score indicate a strength in our model that we will want when trying to minimize certain types of error. As such, we can select the first combination of features we tested, which include the loan intent, borrower’s homeowner status, the interest rate, the loan’s percentage of the borrower’s income, the borrower’s age, and the borrower’s employment history.</p>
<div id="cell-22" class="cell" data-execution_count="28">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>cols <span class="op">=</span> cols1</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>LR <span class="op">=</span> LogisticRegression()</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>LR.fit(X_train[cols], y_train)</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>LR.score(X_train[cols], y_train)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>c:\Users\omara\.conda\envs\ml451\lib\site-packages\sklearn\linear_model\_logistic.py:460: ConvergenceWarning: lbfgs failed to converge (status=1):
STOP: TOTAL NO. of ITERATIONS REACHED LIMIT.

Increase the number of iterations (max_iter) or scale the data as shown in:
    https://scikit-learn.org/stable/modules/preprocessing.html
Please also refer to the documentation for alternative solver options:
    https://scikit-learn.org/stable/modules/linear_model.html#logistic-regression
  n_iter_i = _check_optimize_result(</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="28">
<pre><code>0.8458986336054481</code></pre>
</div>
</div>
<p>With our trained model, we can extract the component of greatest interest (bank pun?): the weights, which indicate how much each feature should be considered. Using the weights, we can convert any set of borrower data into a set of probabilities representing the predicted probability that a given borrower will default on their loans.</p>
<div id="cell-24" class="cell" data-execution_count="29">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>weights <span class="op">=</span> LR.coef_[<span class="dv">0</span>]</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>weights</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="29">
<pre><code>array([18.18778916,  9.26840527, -0.03010567, -0.0267996 , -0.66674985,
       -0.4983932 , -1.81653014,  0.08564683, -0.04352733, -1.01633329,
       -0.14003246, -0.1609493 , -0.6349797 , -0.90020427])</code></pre>
</div>
</div>
</section>
<section id="optimizing-a-threshold" class="level1">
<h1>Optimizing a Threshold</h1>
<p>Using our calculate_norm_scores() function, we can calcuate the predicted probability <span class="math inline">\(s\)</span> that each borrower in our dataset will default on their loans. This works by finding the dot product between the feature data and their corresponding weights and then using min-max scaling to set the dot products on a scale from <span class="math inline">\(0\)</span> to <span class="math inline">\(1\)</span>. We can interpret these values as probabilities where a <span class="math inline">\(1\)</span> represents a <span class="math inline">\(100\%\)</span> chance of defaulting and a <span class="math inline">\(0\)</span> represents a <span class="math inline">\(0\%\)</span> chance of defaulting.</p>
<div id="cell-27" class="cell" data-execution_count="30">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> calculate_norm_scores(X, weights):</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>    unNorm <span class="op">=</span> X<span class="op">@</span>weights</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (unNorm <span class="op">-</span> unNorm.<span class="bu">min</span>())<span class="op">/</span>(unNorm.<span class="bu">max</span>() <span class="op">-</span> unNorm.<span class="bu">min</span>())</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>s <span class="op">=</span> calculate_norm_scores(X_train[cols], weights)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We can plot the probabilities on a histogram to observe the distribution of the borrowers. The data resemble a gaussian where the average borrower appears to have around a <span class="math inline">\(40\%\)</span> chance of default.</p>
<div id="cell-fig-score-histogram" class="cell" data-execution_count="31">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">1</span>, figsize <span class="op">=</span> (<span class="dv">6</span>, <span class="dv">4</span>))</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>hist <span class="op">=</span> ax.hist(s, bins <span class="op">=</span> <span class="dv">50</span>, color <span class="op">=</span> <span class="st">"steelblue"</span>, alpha <span class="op">=</span> <span class="fl">0.6</span>, linewidth <span class="op">=</span> <span class="dv">1</span>, edgecolor <span class="op">=</span> <span class="st">"black"</span>)</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>labs <span class="op">=</span> ax.<span class="bu">set</span>(xlabel <span class="op">=</span> <span class="vs">r"Score $s$"</span>, ylabel <span class="op">=</span> <span class="st">"Frequency"</span>) </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div id="fig-score-histogram" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-score-histogram-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="index_files/figure-html/fig-score-histogram-output-1.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-score-histogram-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1: Histogram of scores. Code sourced from Phil Chodrow Lecture Notes.
</figcaption>
</figure>
</div>
</div>
</div>
<p>Now to choose our threshold. To find the optimal risk cutoff, we can employ the very elegant and efficient brute force approach. We can test <span class="math inline">\(100\)</span> values of our threshold <span class="math inline">\(t\)</span> between <span class="math inline">\(0\)</span> and <span class="math inline">\(1\)</span>, calculating whether each borrower falls above or below the threshold. Borrowers who fall above the threshold are considered to be too high of a risk to give a loan to, while borrowers below the threshold will be approved to receive a loan. We can then compare these labels to the real labels from the “loan_status” column. Based on this, we can calculate the total profit of the bank. If the model predicts that a borrower will pay back their loan and the borrower actually does, the bank will make a profit of <span class="math display">\[loan\_amnt*(1+0.25*int\_rate)^{10} - loan\_amnt\]</span> which assumes that the bank profits <span class="math inline">\(25\%\)</span> of the interest rate after paying operating expenses and that the loan is paid back in ten years. If the model predicts that the borrower will pay back their loans and they actually default, the bank’s profit can be calculated by <span class="math display">\[loan\_amnt*(1 + 0.25*int\_rate)^3 - 1.7*loan\_amnt\]</span> which assumes that the borrower defaults after three years causing the bank to lose <span class="math inline">\(70\%\)</span> of the principal. This amount is typically a negative value. In the banking industry this is considered to be “bad for business”. We can sum the values of these two profits to determine the total profit of the bank. We can calculate the profit yielded by each threshold and then set our best threshold to be whichever yields the highest profit. In our figure below, it appears optimal to reject any borrowers with a risk of default higher than <span class="math inline">\(58\%\)</span>, which yields a profit of <span class="math inline">\(\$1452.12\)</span> per prospective borrower. Not too bad!</p>
<div id="cell-31" class="cell" data-execution_count="32">
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Figure code sourced from Phil Chodrow Lecture Notes and modified for the algorithm used in this post.</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>best_benefit <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>best_threshold <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">1</span>, figsize <span class="op">=</span> (<span class="dv">6</span>, <span class="dv">4</span>))</span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> t <span class="kw">in</span> np.linspace(<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">101</span>): </span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a>    y_pred <span class="op">=</span> s <span class="op">&gt;=</span> t</span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>    tn <span class="op">=</span> np.<span class="bu">sum</span>((X_train[<span class="st">'loan_amnt'</span>]<span class="op">*</span>(<span class="dv">1</span> <span class="op">+</span> <span class="fl">0.25</span><span class="op">*</span>X_train[<span class="st">'loan_int_rate'</span>])<span class="op">**</span><span class="dv">10</span> <span class="op">-</span> X_train[<span class="st">'loan_amnt'</span>])[(y_train <span class="op">==</span> <span class="dv">0</span>)<span class="op">&amp;</span>(y_pred <span class="op">==</span> <span class="dv">0</span>)])</span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>    fn <span class="op">=</span> np.<span class="bu">sum</span>((X_train[<span class="st">'loan_amnt'</span>]<span class="op">*</span>(<span class="dv">1</span> <span class="op">+</span> <span class="fl">0.25</span><span class="op">*</span>X_train[<span class="st">'loan_int_rate'</span>])<span class="op">**</span><span class="dv">3</span> <span class="op">-</span> <span class="fl">1.7</span><span class="op">*</span>X_train[<span class="st">'loan_amnt'</span>])[(y_train <span class="op">==</span> <span class="dv">1</span>)<span class="op">&amp;</span>(y_pred <span class="op">==</span> <span class="dv">0</span>)])</span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a>    benefit <span class="op">=</span> (tn <span class="op">+</span> fn)<span class="op">/</span><span class="bu">len</span>(X_train)</span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a>    ax.scatter(t, benefit, color <span class="op">=</span> <span class="st">"steelblue"</span>, s <span class="op">=</span> <span class="dv">10</span>)</span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> benefit <span class="op">&gt;</span> best_benefit: </span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a>        best_benefit <span class="op">=</span> benefit</span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true" tabindex="-1"></a>        best_threshold <span class="op">=</span> t</span>
<span id="cb22-16"><a href="#cb22-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-17"><a href="#cb22-17" aria-hidden="true" tabindex="-1"></a>ax.axvline(best_threshold, linestyle <span class="op">=</span> <span class="st">"--"</span>, color <span class="op">=</span> <span class="st">"grey"</span>, zorder <span class="op">=</span> <span class="op">-</span><span class="dv">10</span>)</span>
<span id="cb22-18"><a href="#cb22-18" aria-hidden="true" tabindex="-1"></a>labs <span class="op">=</span> ax.<span class="bu">set</span>(xlabel <span class="op">=</span> <span class="vs">r"Threshold $t$"</span>, ylabel <span class="op">=</span> <span class="st">"Benefit per Prospective Borrower"</span>, title <span class="op">=</span> <span class="ss">f"Best Benefit of $</span><span class="sc">{</span>best_benefit<span class="sc">:.2f}</span><span class="ss"> Per Prospective Borrower at Threshold t = </span><span class="sc">{</span>best_threshold<span class="sc">:.3f}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/cell-15-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="evaluating-the-model-as-a-banker" class="level1">
<h1>Evaluating The Model as a Banker</h1>
<p>So how does our model perform on a testing dataset where the model weights have not been influenced by the data it is transforming? Let’s find out!</p>
<div id="cell-34" class="cell" data-execution_count="33">
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>url <span class="op">=</span> <span class="st">"https://raw.githubusercontent.com/PhilChodrow/ml-notes/main/data/credit-risk/test.csv"</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>df_test <span class="op">=</span> pd.read_csv(url)</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>df_test[<span class="st">"loan_int_rate"</span>] <span class="op">=</span> df_test[<span class="st">"loan_int_rate"</span>]<span class="op">/</span><span class="dv">100</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>X_test, y_test <span class="op">=</span> preprocess_data(df_test)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Using the same features we used before and the weights from our trained Logistic Regression model, we can transform the testing data into a set of probabilities as well.</p>
<div id="cell-36" class="cell" data-execution_count="34">
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>s <span class="op">=</span> calculate_norm_scores(X_test[cols], weights)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Using the best threshold we found to be optimal from the training data, we can assign labels to each of our testing borrowers and calculate the bank’s total profit based on these predictions. We find that the bank profits <span class="math inline">\(\$1366.84\)</span> per prospective borrower, which is very similar to the profits we found with the training data. Success!</p>
<div id="cell-38" class="cell" data-execution_count="35">
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>y_pred <span class="op">=</span> s <span class="op">&gt;=</span> best_threshold</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>tn <span class="op">=</span> np.<span class="bu">sum</span>((X_test[<span class="st">'loan_amnt'</span>]<span class="op">*</span>(<span class="dv">1</span> <span class="op">+</span> <span class="fl">0.25</span><span class="op">*</span>X_test[<span class="st">'loan_int_rate'</span>])<span class="op">**</span><span class="dv">10</span> <span class="op">-</span> X_test[<span class="st">'loan_amnt'</span>])[(y_test <span class="op">==</span> <span class="dv">0</span>)<span class="op">&amp;</span>(y_pred <span class="op">==</span> <span class="dv">0</span>)])</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>fn <span class="op">=</span> np.<span class="bu">sum</span>((X_test[<span class="st">'loan_amnt'</span>]<span class="op">*</span>(<span class="dv">1</span> <span class="op">+</span> <span class="fl">0.25</span><span class="op">*</span>X_test[<span class="st">'loan_int_rate'</span>])<span class="op">**</span><span class="dv">3</span> <span class="op">-</span> <span class="fl">1.7</span><span class="op">*</span>X_test[<span class="st">'loan_amnt'</span>])[(y_test <span class="op">==</span> <span class="dv">1</span>)<span class="op">&amp;</span>(y_pred <span class="op">==</span> <span class="dv">0</span>)])</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>benefit <span class="op">=</span> (tn <span class="op">+</span> fn)<span class="op">/</span><span class="bu">len</span>(X_test)</span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>benefit</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="35">
<pre><code>1366.8358295680039</code></pre>
</div>
</div>
</section>
<section id="evaluating-the-model-as-a-borrower" class="level1">
<h1>Evaluating the Model as a Borrower</h1>
<p>While optimizing profits can certaintly be exhilerating, it does not come without its costs. Because the model cannot predict with complete certainty whether a borrower will default, there are bound to be borrowers who are denied loans even if they actually would have been able to pay back their loans. In the name of fairness, we can examine who was approved and denied loans and determine if certain groups of people are advantaged or disadvantaged by our model.</p>
<p>We first look at the average prediction based on the borrowers age. Our model predicts that borrowers from ages <span class="math inline">\(20\)</span> to <span class="math inline">\(30\)</span> will have the highest rate of default at <span class="math inline">\(14.4\%\)</span>. While this does disadvantage young people, the model still predicts the rate of default to be much lower than the actual rate, meaning many young people that are approved a loan will still default. The greatest disparity in predictions is in the <span class="math inline">\(50\)</span> to <span class="math inline">\(60\)</span> year old age group, where only <span class="math inline">\(2.9\%\)</span> are predicted to default when this group actually has the highest rate at <span class="math inline">\(28.9\%\)</span>.</p>
<div id="cell-41" class="cell" data-execution_count="36">
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>df_test[<span class="st">"y_pred"</span>] <span class="op">=</span> y_pred</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>df_test.groupby(pd.cut(df_test[<span class="st">"person_age"</span>], [<span class="dv">20</span>,<span class="dv">30</span>,<span class="dv">40</span>,<span class="dv">50</span>,<span class="dv">60</span>,<span class="dv">80</span>]))[[<span class="st">"y_pred"</span>, <span class="st">"loan_status"</span>]].mean().reset_index()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="36">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">person_age</th>
<th data-quarto-table-cell-role="th">y_pred</th>
<th data-quarto-table-cell-role="th">loan_status</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>(20, 30]</td>
<td>0.143839</td>
<td>0.223499</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>(30, 40]</td>
<td>0.088584</td>
<td>0.208466</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>(40, 50]</td>
<td>0.054545</td>
<td>0.202429</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>(50, 60]</td>
<td>0.029412</td>
<td>0.289474</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>(60, 80]</td>
<td>0.083333</td>
<td>0.461538</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>Next we can look at the predictions for default based on loan intent. Just as with the age groups, the predicted rates of default are much lower than the actual rates of default, although by varying amounts. Among the highest predicted rates of default are medical expenses with a predicted rate of <span class="math inline">\(19.6\%\)</span> compared to the actual default rate of <span class="math inline">\(28.2\%\)</span>. This means it is significantly harder to get approved for a medical loan than other loans like education or venture loans, which are given predicted default rates of <span class="math inline">\(6.3\%\)</span> and <span class="math inline">\(8.4\%\)</span> respectively.</p>
<div id="cell-43" class="cell" data-execution_count="37">
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>df_test.groupby(<span class="st">"loan_intent"</span>)[[<span class="st">"y_pred"</span>, <span class="st">"loan_status"</span>]].mean().reset_index()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="37">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">loan_intent</th>
<th data-quarto-table-cell-role="th">y_pred</th>
<th data-quarto-table-cell-role="th">loan_status</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>DEBTCONSOLIDATION</td>
<td>0.201327</td>
<td>0.279497</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>EDUCATION</td>
<td>0.062925</td>
<td>0.167421</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>HOMEIMPROVEMENT</td>
<td>0.118506</td>
<td>0.246088</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>MEDICAL</td>
<td>0.195713</td>
<td>0.281553</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>PERSONAL</td>
<td>0.119238</td>
<td>0.219227</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">5</td>
<td>VENTURE</td>
<td>0.084025</td>
<td>0.145701</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>Lastly, we can look at income brackets. Borrowers that make less than <span class="math inline">\(\$40000\)</span> are the most likely to default, which the model reflects by making it the most difficult for these borrowers to access credit. As the income brackets increase, the model predicts lower and lower rates of default even though the actual rates of default seem to level off above <span class="math inline">\(\$70000\)</span>.</p>
<div id="cell-45" class="cell" data-execution_count="38">
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>df_test[<span class="st">"y_pred"</span>] <span class="op">=</span> y_pred</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>df_test.groupby(pd.cut(df_test[<span class="st">"person_income"</span>], [<span class="dv">0</span>,<span class="dv">40000</span>,<span class="dv">70000</span>,<span class="dv">100000</span>, <span class="dv">150000</span>,<span class="dv">1000000</span>]))[[<span class="st">"y_pred"</span>, <span class="st">"loan_status"</span>]].mean().reset_index()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="38">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">person_income</th>
<th data-quarto-table-cell-role="th">y_pred</th>
<th data-quarto-table-cell-role="th">loan_status</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>(0, 40000]</td>
<td>0.236352</td>
<td>0.370569</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>(40000, 70000]</td>
<td>0.121875</td>
<td>0.198972</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>(70000, 100000]</td>
<td>0.068262</td>
<td>0.119625</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>(100000, 150000]</td>
<td>0.012797</td>
<td>0.105008</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>(150000, 1000000]</td>
<td>0.00495</td>
<td>0.115044</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
</section>
<section id="conclusion" class="level1">
<h1>Conclusion</h1>
<p>Throughout this post, we examine automated decision algorithms, which take advantage of threshold setting to determine if borrowers should be approved loans or not. By assigning variable costs to different kinds of errors, we define our optimal model as one that does not necessarily minimize all error, but minimizes a specific kind of error. Using this approach, we find parameters that can be used to maximize the profit for our bank. One of the ethical concerns with implementing an algorithm like this is that certain demographs are likely to be assigned higher or lower risk scores simply based on the demographic they are part of. As such, certain groups can be unfairly advantaged or disadvantaged in decision-making processes like approving loans. In the case of the bank, one such concern is that people seeking medical loans have higher rates of default and thus are denied credit by the model at higher rates. This brings up the question: is this fair? From a profit standpoint, this certaintly is fair as the bank wants to minimize the risk they take on when giving credit and riskier investments should be taken on less frequently. However, from a humanitarian standpoint, this is an unfair policy as medical expenses are often for life-or-death procedures and it could be considered inhumane to deny the borrower the money they need for such a procedure even if they are perhaps unable to pay it back. Thus it comes down to how you define fairness: Is fairness based on equal exchanges and kept promises or is it our responsibility as humans to provide for one another even when there is no direct benefit to us? It seems that there are some decisions that even the best machines cannot make.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>